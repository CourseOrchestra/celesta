= Особенности работы Celesta с поддерживаемыми типами СУБД
:lang: ru
:is-main-doc:
include::_doc_general_attributes.adoc[]
:toclevels: 3
:doctype: book
:img: img
:lupa: icon:search[]
:source-highlighter: highlightjs

//tag::supported_rdbms[]

Система по возможности прозрачно для разработчиков решения поддерживает MS SQL Server, Oracle, Postgre SQL и H2.

Хотя решения Celesta свободно переносимы между разными типами поддерживаемых СУБД, тем не менее, каждая из этих СУБД имеет особенности настройки. Кроме того, разные функциональные возможности Celesta по-разному реализованы в разных СУБД. Этим особенностям посвящён данный раздел.

Соответствие типов данных Celesta и СУБД приведено в разделе «Язык Celesta-SQL: типы данных».

== MS SQL Server

=== Особенности реализации

* Понятию «гранула» соответствует понятие «схема» (SCHEMA).

* Автоинкрементные поля эмулируются при помощи триггеров и таблицы celesta.sequences. Причина в том, что встроенная функциональность IDENTITY в MS SQL Server слишком негибка: установив IDENTITY на столбец таблицы, как-либо поменять это свойство (или этот столбец) без пересоздания всей таблицы с нуля уже невозможно, Celesta же предполагает гибкость изменений структуры.

NB: Начиная с версии 2012, MS SQL Server поддерживает sequences. Планируется доработка Celesta для перехода к использованию функциональности sequences для автоинкрементных полей.

== Oracle

=== Особенности настройки

*Ошибка ORA-12705: Cannot access NLS data files...* Если при запуске Celesta на Oracle Express Edition возникает ошибка "ORA-12705: Cannot access NLS data files or invalid environment specified", в числе аргументов JVM необходимо задать параметр

[source,sql]
-Duser.country=US

Если Celesta запускается из Flute или Showcase, то задать этот параметр можно на вкладке Java, поле Java Options программ Flute2w.exe или Tomcat7w.exe, используемых для управления сервисами Flute/Tomcat.

Эта проблема является общей для связки Oracle XE + JDBC и актуальна только для Oracle Express Edition, в прочих (production) версиях Oracle Database она не актуальна.

Минимальные настройки прав доступа для USER'а в БД *Oracle 11g*:

[source,sql]
GRANT
	CONNECT,
	RESOURCE,
	CREATE TABLE,
	CREATE PROCEDURE,
	CREATE VIEW,
	CREATE SEQUENCE,
	CREATE TRIGGER,
	SELECT ANY DICTIONARY
	TO <USER>

В некоторых организациях по умолчанию не дают право доступа SELECT ANY DICTIONARY, из-за чего может возникать ошибка "ORA-00942: table or view does not exist" при разворачивании системной гранулы Celesta.

=== Особенности реализации

* Гранула — префикс в имени таблицы, отделённый знаком подчёркивания, при этом работает ограничение Oracle на длину имени таблицы — 30 символов. Причина в том, что понятие «схема» в Oracle несколько отличается от такового для других СУБД, создание «схем» в Oracle связано с созданием новых пользователей, на что на практике не могут быть выданы права администраторами Oracle-серверов, на которых хранятся промышленные данные.

* Автоинкрементные поля реализуются при помощи sequences (для каждой таблицы с автоинкрементным полем создаётся SEQUENCE с именем <имя таблицы>_inc) и BEFORE INSERT-триггеров.

* Oracle не поддерживает конструкцию FOREIGN KEY ... ON UPDATE/DELETE SET NULL, поэтому она эмулируется при помощи триггеров.

== PostgreSQL

=== Особенности реализации

* Понятию «гранула» соответствует понятие «схема» (SCHEMA).

* Автоинкрементные поля реализуются при помощи sequences (для каждой таблицы с автоинкрементным полем создаётся SEQUENCE с именем <имя таблицы>_seq) и специальных DEFAULT-значений на полях, берущих значения из соответствующих sequenc'ов.

При использовании Celesta для доступа к существующей заранее (а не создаваемой и обновляемой в Celesta) базе данных может возникнуть проблема с полями типа uuid. Сама Celesta типа данных uuid как такового не поддерживает, но может работать с ним через поле типа VARCHAR(36). При этом не возникает проблем в MS SQL Server, но для работы Celesta в Postgres требуется явно определить оператор сравнения varchar с uuid и имплицитное изменение типов при присвоении:

[source,sql]
CREATE OR REPLACE FUNCTION celesta.uuidequal(a1 uuid, a2 CHARACTER VARYING)
  RETURNS BOOLEAN AS 'select a1::varchar = a2'
  LANGUAGE SQL IMMUTABLE;
CREATE OPERATOR = (
    LEFTARG = uuid,
    RIGHTARG = CHARACTER VARYING,
    PROCEDURE = celesta.uuidequal
);
CREATE CAST (character varying AS uuid)
    WITH  INOUT AS ASSIGNMENT;


== H2

=== Особенности настройки

* Для упрощенной инициализации inmemory db в файл celesta.properties можно добавить настройку "h2.in-memory=true". В таком случае строка jdbc подключения будет игнорироваться, а также логин и пароль пользователя.

* В celesta.properties добавлена поддержка настройки h2.referential.integrity=false(по умолчанию)/true. Выключенная настройка означает, что ограничения типа constraint будут проигнорированы при записи в БД. При включении ограничения будут обрабатываться как в других РСУБД. Для установки данной настройки не в inmemory БД пользователь должен обладать правами администратора(поле "ADMIN" в таблице "INFORMATION_SCHEMA.USERS") Данная настройка срабатывает один раз при инициализации приложения и для обновления требуется его перезапуск.

=== Особенности реализации

* Понятию «гранула» соответствует понятие «схема» (SCHEMA).

* Автоинкрементные поля реализуются при помощи sequences (для каждой таблицы с автоинкрементным полем создаётся SEQUENCE с именем <имя таблицы>_seq) и специальных DEFAULT-значений на полях, берущих значения из соответствующих sequenc'ов.

* Поля 'recversion' управляются триггером, написанном на Java и реализующим интерфейс org.h2.api.Trigger. H2 не поддерживает триггеры, логика которых заключена в процедурном SQL.

//end::supported_rdbms[]
