= Проектирование базы данных Celesta в DBSchema
:lang: ru
:is-main-doc:
include::_doc_general_attributes.adoc[]
:toclevels: 3
:doctype: book
:img: images
:lupa: icon:search[]
:source-highlighter: highlightjs

//tag::dbschema[]
== Синхронизация метаданных Celesta и проекта DBSchema

https://dbschema.com/[DBSchema] представляет собой удобный инструмент визуального моделирования структуры базы данных. Имеется возможность полностью моделировать в DBSchema всю информацию Celesta о структуре БД (таблицы, поля, ключи, индексы), а также наоборот — превратить существующий Score в проект DBSchema.

image::{img}/800px-Dbschemascreen.png[{image-100-width}]

=== Настройка системы

Для работы вам понадобится:

. https://dbschema.com/[DBSchema] (программа проприетарная).

. Утилита https://github.com/courseorchestra/dbschemasync[`dbschemasync`]. Актуальную сборку утилиты `dbschemasync` можно взять, например, https://artifactory.corchestra.ru/artifactory/list/libs-release-local/ru/curs/dbschemasync/[здесь]. 

Распакуйте zip-архив и поместите папку Celesta с настройками DBSchema в `%userprofile%\.DbSchema\config\rdbms\`.

В папке `/bin` zip-архива находится исполняемый файл `dbschemasync`.

=== Запуск синхронизации

Утилита `dbschemasync` принимает два параметра:

* Score path

* имя DBS-файла (проекта DBSchema)

Направление синхронизации определяется последовательностью аргументов: если первым аргументом идёт Score Path, то синхронизация идёт от Score к проекту DBSchema, если же первым аргументом идёт имя проекта DBSchema, то синхронизация идёт от DBSchema к Score.

Пример команды для синхронизации от score к схеме:

```
dbschemasync "c:/temp/dbschema/score/" "c:/temp/dbschema/schema.dbs"
```

Пример синхронизации от схемы к score:

```
dbschemasync "c:/temp/dbschema/schema.dbs" "c:/temp/dbschema/score/"
```

=== Особенности работы при дизайне структуры БД

Всё, что находится в <<CelestaDoc,CelestaDoc>>, переводится в Documentation-поля DBSchema, и наоборот.

image::{img}/800px-Dbschemascreen3.png[{image-100-width}]

Опции таблицы (`WITH (NO) VERSION CHECK`, `WITH READ ONLY`...) находятся на вкладке Storage:

image::{img}/Dbschemascreen4.png[{image-80-width}]

В DBSchema, чтобы задать версию гранулы, необходимо модифицировать мнимую «хранимую процедуру», имеющую то же название, что и гранула (сами хранимые процедуры для Celesta в DBSchema, естественно, не моделируются):

image::{img}/Dbschemascreen2.png[{image-80-width}]

== Создание CelestaSQL-скриптов на основе структуры существующей БД

Эта технология рекомендована всем, у кого возникнет задача создания CelestaSQL-скриптов для уже существующей базы данных. Использование каких-либо иных путей (например, выгрузка SQL-скрипта из базы данных и ручная его «вычистка») по опыту является гораздо более трудоёмким занятием.

Для этого требуется программа DBSchema с установленной поддержкой Celesta. Шаги следующие:

. Присоединяем DBSchema к нужной базе данных и методом Reverse Engineering закачиваем всю нужную нам структуру (на этом этапе можно ограничиться только теми таблицами и связями, которые нас интересуют в Celesta). Убедитесь, что «забрали» все нужные таблицы, т. к. на следующих шагах проект придётся «отсоединить» от базы данных и автоматически получить сведения о таблицах уже не получится.

. Отключаем DBSchema от базы данных (offline) и меняем тип базы с SQL Server на Celesta через меню Project->Project Settings (естественно, предполагается, что к этому моменту в DBSchema установлена надстройка для синхронизации с Celesta). Откроется окно, в котором DBSchema предложит сопоставить типы. Необходимо аккуратно прописать соответствие типов для Celesta: например, для SQL Server  `VARCHAR(MAX)` перевести в `TEXT`, `UUID` -- в `VARCHAR(36)` и так далее.

. После нажатия на OK мы получаем DBSchema-проект, ориентированный на Celesta. В этот момент его можно сохранить в отдельном месте: он больше не привязан к исходной базе данных. Однако это — некорректный проект, т. к. нет деления на гранулы, гранулам не даны объявления, и в нём ещё много фич, нехарактерных для Celesta. На этом этапе мы вручную должны создать гранулы (схемы) и разложить по ним таблицы.

. Если теперь воспользоваться утилитой schemasync.jar, то мы, скорее всего, получим сообщения об ошибках, т. к. проект остаётся некорректным. Поэтому следует воспользоваться командой Schema-->Generate Schema Script для выгрузки всех таблиц в один sql-файл. Получившийся скрипт будет очень хорошим приближением к Celesta-скрипту, и вот это приближение уже удобно доделать вручную: убрать использование не поддерживаемых в Celesta функций, раздробить на разные файлы, что-то сделать с названиями длиннее 30 символов и т. д.

. Настало время пробовать запускать Celesta с вашими скриптами.

. Если вы дальше желаете использовать DBSchema, то лишь после того, как Celesta "согласится" работать с вашими скриптами, имеет смысл воспользоваться утилитой schemasync.jar для связи с абсолютно пустым проектом DBSchema ("промежуточный" проект DBSchema вы можете удалить). Это связано с тем, что в schemasync.jar встроен "челестовский" парсер SQL-скриптов, и он не сможет работать с тем, с чем не может работать сама Celesta.

== Выгрузка в PlantUML

При запуске `dbschemasync` в режиме конвертации из DBSchema в score третья опция командной строки `-adoc`  параллельно формирует диаграммы в формате https://plantuml.com[PlantUML] для каждой из диаграмм DBSchema. Имена файлов диаграмм соответствуют названиям листов DBSchema с диаграммами.

//end::dbschema[]
