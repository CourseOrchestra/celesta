= Триггеры
:lang: ru
:is-main-doc:
include::_doc_general_attributes.adoc[]
:toclevels: 3
:doctype: book
:img: images
:lupa: icon:search[]
:source-highlighter: highlightjs

//tag::triggers[]

Триггером называется написанная создателем решения функция, принимающая в качестве аргумента экземпляр курсора, присоединённая к классу курсора, автоматически вызываемая при вставке, удалении и модификации записи. Триггер имеет тип https://docs.oracle.com/javase/8/docs/api/index.html?java/util/function/Consumer.html[`Consumer<YourCursor>`].

При действиях insert(), update() и delete() система вызывает определённые создателем решения pre- (выполняемые до модификации данных в базе) и post- (выполняемые после модификации данных в базе) триггеры. Таким образом, всего существует шесть типов триггеров:

[cols="^1, ^1", options="header"]
|====
^.^|pre-триггеры
^.^|post-триггеры

|onPreInsert
|onPostInsert

|onPreUpdate
|onPostUpdate

|onPreDelete
|onPostDelete

|====

IMPORTANT: Чаще всего имеет смысл пользоваться pre-триггерами, чтобы выполнить некоторые действия до того, как изменение будет внесено в базу. Однако обратите внимание: т. к. триггер onPreInsert выполняется до отправки содержимого курсора в базу данных, то на момент его выполнения не заполняются значения полей, обладающих свойствами `DEFAULT` или `GETDATE()`. Для их автозаполнения средствами БД следует присваивать им значение `null`. В триггере onPostInsert эти поля уже будут заполнены.

В триггере onPreUpdate удобно воспользоваться <<xrec_section,объектом xRec>>, чтобы определить, какие именно поля собираются быть изменёнными в таблице. В триггере onPostUpdate объектом xRec воспользоваться уже нельзя, т. к. он становится равным текущему буферу.

Триггеров каждого типа на одной таблице может быть сколько угодно. Триггер для любой таблицы может быть определён с помощью *статических* методов `onPreInsert`, `onPreDelete` и т. д. на классах
курсоров. Определение триггеров с помощью статических методов делает их «глобальными», т. е. выполняющимися при любом взаимодействии с таблицей.

Т. к. метод регистрации триггера требует указания экземпляра класса {apidocs}ru/curs/celesta/Celesta.html[`Celesta`], в Spring-приложениях
для регистрации триггеров удобно использовать метод `@PostConstruct`:

```java
@Service
public class MyService {

    @Autowired
    private ICelesta celesta;

    @PostConstruct
    public void init(){
        MyCursor.onPreInsert(celesta, c ->
                System.out.printf("Record %s is going to be inserted!%n", c.getId()));
    }

    . . .
}
```

Кодогенерируемый класс `MyCursor` имеет метод

```java
public static void onPreInsert(ICelesta celesta, Consumer<MyCursor> cursorConsumer)
```

Системные курсоры (из пакета {apidocs}ru/curs/celesta/syscursors/package-summary.html[`ru.curs.celesta.syscursors`]) также поддерживают возможность регистрировать триггеры.

//end::triggers[]
