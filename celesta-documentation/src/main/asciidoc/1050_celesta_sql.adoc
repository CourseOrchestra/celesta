= Язык Celesta-SQL
:lang: ru
:is-main-doc:
include::_doc_general_attributes.adoc[]
:toclevels: 3
:doctype: book
:img: images
:lupa: icon:search[]
:source-highlighter: highlightjs

//tag::celesta_sql[]

== Язык CelestaSQL определения объектов базы данных

IMPORTANT: Скрипты на языке CelestaSQL должны иметь кодировку UTF-8 без https://en.wikipedia.org/wiki/Byte_order_mark#UTF-8[символа BOM].

На языке Celesta SQL пишутся скрипты определения гранул. Скрипт на языке CelestaSQL состоит из конструкций

* <<create_schema_statement,CREATE GRAIN>>,
* <<create_sequence_statement,CREATE SEQUENCE>>,
* <<create_table_statement,CREATE TABLE>>,
* <<foreign_keys_statements,ALTER TABLE ADD ... FOREIGN KEY>>,
* <<create_index_statement,CREATE INDEX>>,
* <<create_view_statement,CREATE VIEW>>,
* <<create_materialized_view_statement,CREATE MATERIALIZED VIEW>>,
* <<create_function_statement,CREATE FUNCTION>>,

в обязательном порядке разделённых точкой с запятой, начиная с `CREATE GRAIN`:

image::{img}/1.file.png[{image-60-width}]

== Комментарии в языке CelestaSQL

CelestaSQL поддерживает стандартные однострочные и многострочные комментарии, а также комментарии <<1060_celesta_doc.adoc#,CelestaDoc>>:

[source,sql]
-- однострочный комментарий
/*многострочный
    комментарий*/
 /**комментарий CelestaDoc*/


Обычные комментарии могут использоваться в любом месте текста, комментарии CelestaDoc — только непосредственно перед определением гранулы, таблицы, поля или индекса.

== Идентификаторы объектов в языке CelestaSQL

Идентификаторы объектов — это, иначе говоря, имена гранул, таблиц, полей, индексов, ограничений и представлений, их синтаксис в Celesta имеет ряд строгих ограничений.

. В обычных СУБД дозволяется, чтобы идентификаторы объектов содержали знаки пробела и неалфавитные знаки, если эти имена заключены в обрамляющие символы, например «[]» для MS SQL Server. Т. е. в MS SQLServer допустимо, например, такое имя таблицы: [Long Table$Name]. Celesta, однако, не может поддерживать пробелы и неалфавитные знаки в идентификаторах потому, что имя каждой Celesta-таблицы должно являться именем Python-класса, а имя каждого Celesta-поля — именем Python-переменной. Поэтому идентификатор любого именованного объекта CelestaSQL должен удовлетворять правилам наименования переменной в Python, т. е. *может состоять только из больших и малых букв латинского алфавита, цифр и знаков подчёркивания, при этом не может начинаться с цифры*.

. *Заключение идентификаторов Celesta в кавычки* в скриптах CelestaSQL *не допускается* на уровне синтаксиса, т. к. практической надобности в этом нет (имена никогда не содержат пробелов). На системном уровне при формировании запросов к СУБД Celesta, однако, всегда заключает имена своих объектов в прямые кавычки ("ANSI quotes"), чтобы гарантировать, что базы данных Oracle, PostgreSQL и H2 не будут нарушать регистр букв, составляющих идентификатор.

. *Идентификаторы* в Celesta *являются чувствительными к регистру*, однако нельзя создавать две таблицы, имена которых отличаются только регистром.

. *Длина* любого идентификатора в Celesta *не может быть больше 30 символов*.

. *Идентификаторы (префиксы) гранул, кроме того, не могут содержать в себе знаков подчёркивания*. Это связано с тем, что комбинация имени гранулы со знаком подчёркивания и другим идентификатором зачастую используется во внутрисистемных целях Celesta, и запрет на использование знака подчёркивания в именах гранул необходим для исключения возможных неоднозначностей.

[[create_schema_statement]]
== Конструкция CREATE GRAIN (SCHEMA)

Единственной конструкцией, отличающей Celesta SQL от стандартного языка DDL, является выражение CREATE GRAIN, с которого должен начинаться любой скрипт определения гранулы. Используется следующий синтаксис (слова GRAIN и SCHEMA являются синонимами):

image::{img}/2.create_grain.png[{image-90-width}]

[[create_sequence_statement]]
== Конструкция CREATE SEQUENCE

Используется следующий синтаксис:

image::{img}/3.create_sequence.png[{image-100-width}]

Основными ограничениями и отличиями такого запроса от SQL-запросов в различных СУБД являются:

. Не поддерживается в версиях MSSQL ниже 2011

. Если не указано значение MINVALUE, то оно автоматически выставляется равным значению START WITH (по умолчанию 1)

. Если не указано значение MAXVALUE, то оно автоматически выставляется равным значению Long.MAX_VALUE

. Значение START WITH не обновляется для созданных ранее последовательностей, даже если было изменено в файле гранулы (связано с тем, что oracle разрешает данную операцию только через удаление и пересоздание последовательности, а идеология celesta не предусматривает удаление statefull объектов из БД)

. Если в грануле присутствует таблица с именем, например, A, то является недопустимым создание последовательности с именем A_seq, так как это имя зарезервировано системой

[[create_table_statement]]
== Конструкция CREATE TABLE

Используется следующий синтаксис:

image::{img}/3.create_table.png[{image-100-width}]

image::{img}/4.table_constituent.png[{image-70-width}]

Иными словами, в конструкции CREATE TABLE в скобках через запятую в любом порядке могут быть перечислены определения полей, опредления первичных ключей или определения внешних ключей, а за скобками, возможно, перечислены опции. На практике определения всех полей идут подряд в самом начале, далее — определения составных первичных ключей (первичные ключи, состоящие из одного поля, можно определять на самом поле) и определения составных внешний ключей (опять же, внешние ключи, состоящие из одного поля, можно определять на самом поле).

=== Определения полей

image::{img}/4.field_definition.png[{image-100-width}]

*field_definition* (Определение поля) — конструкция, задающая тип поля, название поля, его свойства NULL/NOT NULL и DEFAULT, опционально может заканчиваться конструкцией PRIMARY KEY и/или FOREIGN KEY.

Сокращенное определение внешнего ключа (*inline_fk_definition*) имеет следующий синтаксис:

image::{img}/5.inline_fk_definition.png[{image-100-width}]

Здесь *table_ref* — ссылка на таблицу, которая может быть однокомпонентной (если таблица, на которую указывает внешний ключ, находится в текущей грануле) или двухкомпонентной, с явным указанием имени гранулы:

image::{img}/6.table_ref.png[{image-60-width}]

Определение синтаксиса правил внешних ключей (*fk_rules*) см. в разделе <<foreign_keys_statements,Внешние ключи»>>.

=== Типы данных

Используется следующая система типов данных.

[cols="1, 1, 1, 1, 1, 1, 1, options="header"]
|====
^.^|
^.^|CELESTA
^.^|Microsoft SQL Server
^.^|Oracle
^.^|PostgreSQL
^.^|H2
^.^|Java Type For Cursor

|nteger (32-bit)
|INT
|INT
|NUMBER
|INT4
|INTEGER
|java.lang.Integer

|Floating point (64-bit)
|REAL
|FLOAT(53)
|REAL
|FLOAT8
[= DOUBLE PRECISION]
|DOUBLE
|ava.lang.Double

|Fixed point (decimal)
|DECIMAL(p,s)
|DECIMAL(p,s)
|NUMBER(p,s)
|NUMERIC(p,s)
|DECIMAL(p,s)
|java.math.BigDecimal

|String (Unicode)
|VARCHAR(n)
|NVARCHAR(n)
|NVARCHAR(n)
|VARCHAR(n)
|VARCHAR(n)
|java.lang.String

|Long string (Unicode)
|TEXT
|NVARCHAR(MAX)
|NCLOB
|TEXT
|CLOB
|java.lang.String

|Binary
|BLOB
|VARBINARY(MAX)
|BLOB
|BYTEA
|VARBINARY(MAX)
|java.lang.String

|Date/Time
|DATETIME
|DATETIME
|TIMESTAMP
|TIMESTAMP
|TIMESTAMP
|java.util.Date

|DateTime With Time Zone
|DATETIME WITH TIME ZONE
|DATETIMEOFFSET
|TIMESTAMP WITH TIME ZONE
|TIMESTAMPZ
|TIMESTAMP WITH TIME ZONE
|java.time.ZonedDateTime

|Boolean
|BIT
|BIT
|NUMBER
[check in (0, 1)]
|BOOL
|BOOLEAN
|java.lang.Boolean

|====


См. также раздел «<<RDBMS_peculiarities,Особенности работы Celesta с поддерживаемыми типами СУБД>>».

Для каждого типа поля имеется свой вариант определения:

image::{img}/8.int_field.png[{image-100-width}]

Вместо конструкции DEFAULT <целое число> для поля с типом INT может использоваться конструкция NEXTVAL(<sequence name>). Таким образом значение колонки будет инкрементироваться при вставке в зависимости от указанной последовательности. Стоит отметить, что можно использовать только последовательности, объявленные в той же грануле, что и таблица, к которой принадлежит колонка.

image::{img}/9.floating_field.png[{image-90-width}]

image::{img}/795px-13.decimal_field.png[{image-100-width}]

image::{img}/10.text_field.png[{image-100-width}]

image::{img}/11.blob_field.png[{image-90-width}]

Здесь *<binary literal>* — шестнадцатеричное представление последовательности байтов, начинающееся с 0x и не заключённые в кавычки, например: 0xFFAAFFAAFF.

image::{img}/12.datetime_field.png[{image-100-width}]

В качестве значения DEFAULT для поля с типом DATETIME может использоваться функция GETDATE() (текущий момент времени).

image::{img}/17.datetime_with_time_zone_field.png[{image-70-width}]

image::{img}/13.bit_field.png[{image-80-width}]

=== Первичные ключи

image::{img}/14.primary_key_definition.png[{image-60-width}]

*primary_key_definition* (определение первичного ключа) — конструкция, задающая состав полей, входящих в первичный ключ таблицы. Возможно в двух вариантах:

* сокращённый вариант — когда ключевые слова “PRIMARY KEY” идут сразу после определения поля, это даёт возможность более короткой и наглядной записи в случае, когда первичный ключ состоит всего из одного поля

* полный вариант — когда конструкция PRIMARY KEY находится в определении таблицы среди определения полей, и может содержать как одно поле, так и любое количество полей.

Ограничения:

* *Самое важное: для обеспечения работоспособности системы не допускается создание таблиц без PRIMARY KEY*. (За исключением READ ONLY-таблиц).

* В таблице может быть не более одного упоминания PRIMARY KEY, будь то сокращённое выражение в конце определения поля или составное выражение в определении таблицы.

* Не допускается создание PK по полям с типами BLOB и TEXT.

* Не допускается создание PK по nullable-полям.

* Не допускается более одного вхождения одного и того же поля в определение PRIMARY KEY.

[[foreign_keys_statements]]
=== Внешние ключи

image::{img}/15.foreign_key_definition.png[{image-100-width}]

*foreign_key_definition* (Определение внешнего ключа) — конструкция, задающая связь между таблицами по одному или нескольким полям. Как и в случае с конструкцией PRIMARY KEY, возможно использование в двух вариантах — сокращённом (встроенном в определение поля, связь по одному полю) и полном (перечисляется среди определений полей). Кроме того, внешний ключ можно создать вне определения таблицы при помощи конструкции "alter table add constraint foreign key":

image::{img}/16.add_foreign_key.png[{image-100-width}]

Ограничения:

* Foreign key, простой или составной, может ссылаться только на Primary Key, причём полностью. (В Celesta SQL не допускаются ограничения UNIQUE, поэтому из двух возможностей, стандартно предлагаемых в СУБД для Foreign Keys, остаётся только возможность ссылки на Primary Key).

* Типы полей должны в точности совпадать (если поле – строковое, длина ссылающегося поля должна быть точно равна длине поля, на которое ссылаются).

* Нельзя создать более одного определения Foreign Key на одном и том же наборе столбцов (частный случай – не может быть двух FK, определённых для одного и того же столбца).

*fk_rules* — ссылочные действия:

image::{img}/7.fk_rules.png[{image-100-width}]

Поддерживаемые ссылочные действия:

* NO ACTION – запрет удаления/модификации родительской записи, если на неё есть ссылки

* SET NULL – выставление NULL в ссылках. Внимание: естественно, использовать это действие запрещено для NOT NULL-able полей

* CASCADE – каскадное удаление/обновление полей.

В момент создания foreign key сослаться можно только

* на таблицу, определённую в текущей грануле выше по тексту

* на таблицу, определённую с другой грануле.

WARNING:  «Зацикленные» ссылки по foreign key (например, вида A->B->C->A) при разработке структуры базы данных в действительности нужны крайне редко и обычно говорят об ошибке проектировщика. Единственный широко применимый практически значимый пример «зацикливания» — ссылка таблицы на саму себя при организации иерархического перечня по принципу parent-child.

В Celesta не допускается создание «зацикленных» ссылок между таблицами, принадлежащими разным гранулам. Если надо организовать ссылки по кругу между несколькими таблицами внутри гранулы, то это можно сделать, воспользовавшись конструкцией "alter table add constraint foreign key".

В частности, работает следующий пример:

[source, sql]
CREATE TABLE aa(idaa INT NOT NULL PRIMARY KEY, idc INT , textvalue nvarchar(10));

[source, sql]
CREATE TABLE a (ida INT NOT NULL PRIMARY KEY, descr nvarchar(2), parent INT
                FOREIGN KEY REFERENCES a(ida), --ссылка таблицы на саму себя
                fff INT FOREIGN KEY REFERENCES aa(idaa) --первая часть круговой ссылки

внешний ключ, создаваемый вне таблицы:

[source, sql]
ALTER TABLE aa ADD CONSTRAINT fk1
FOREIGN KEY (idc) REFERENCES a(ida); --вторая часть круговой ссылки
</syntaxhighlight>


Пример создания составного ключа, состоящего из двух полей:

[source, sql]
<syntaxhighlight lang ="sql">
CREATE TABLE empfiles(
  id INT NOT NULL PRIMARY KEY,
  user_id varchar(200) NOT NULL,
  orgtype_id varchar(255) NOT NULL,
  question_id varchar(30) NOT NULL,
  FOREIGN KEY (orgtype_id, question_id) REFERENCES schema.table(field, field)

[[celestasql_with_options]]
=== Опции

Celesta позволяет указывать следующие опции после определения таблицы:

image::{img}/5.table_options.png[{image-100-width}]

Таким образом, поддерживаются следующие возможности:

* WITH VERSION CHECK — режим по умолчанию: включение механизма отслеживания версий записей для исключения потерянных обновлений (см. раздел Защита от потерянных обновлений). Указывать данную опцию явно не требуется.

* WITH NO VERSION CHECK — отключение механизма отслеживания версий записей. Требуется в случаях, когда нет желания вводить новое системное поле в таблицу. Возможность модифицировать данные в таблице при этом сохраняется, но возможны «потерянные обновления».

* WITH READ ONLY — режим «только чтение». Требуется в случаях, когда данные таблицы поступают из внешних источников, а не заносятся средствами Celesta, либо если необходимо подключиться к таблице, относящейся к иному приложению, и потому нежелательно вносить в её структуру какие-либо изменения. В этом режиме механизм отслеживания версий записей отключается, а ORM-класс для доступа к таблице генерируется без методов модификации данных. Кроме того, для таких таблиц не требуется указывать первичный ключ.

* Опция NO AUTOUPDATE, которая может применяться совместно с данными опциями, отключает таблицу от процесса автообновления базы данных. Используется в случае, когда структура какой-либо таблицы изменяется в базе данных вручную и система не должна пытаться синхронизировать структуру этой таблицы с описанием на языке CelestaSQL автоматически.

[[create_index_statement]]
== Конструкция CREATE INDEX

Индексы применяются для ускорения фильтрации по полям таблиц и создаются при помощи следующей синтаксической конструкции:

image::{img}/17.create_index.png[{image-100-width}]

Имена индексов должны быть уникальны в пределах гранулы. Все индексы в Celesta допускают неуникальные значения.

[[create_view_statement]]
== Конструкция CREATE VIEW

Представления (views) служат для доступа только на чтение к данным, собранным из одной или нескольких таблиц при помощи SQL-запроса SELECT. Для каждого своего представления Celesta создаёт объект-представление в базе данных, транслируя при этом SQL-запрос на языке CelestaSQL в соответствующий диалект языка SQL.

Представления создаются при помощи синтаксической конструкции

image::{img}/18.create_view.png[{image-70-width}]

* *<view name>* (имя представления) должно быть уникальным в пределах гранулы и не совпадать с именем таблицы.

* *query* (запрос) представляет собой SQL-запрос, имеющий следующий синтаксис:

image::{img}/800px-19.query.png[{image-100-width}]

image::{img}/800px-20.from_clause.png[{image-100-width}]

Основными ограничениями и отличиями такого запроса от SQL-запросов в различных СУБД являются:

. Запросы строятся только на таблицах (текущей гранулы или соседних гранул). Во избежание выстраивания неэффективных конструкций невозможно построение запросов на представлениях.

. Конструкция SELECT * не поддерживается, и всякое поле запроса, если только это не ссылка на поле таблицы с уникальным в рамках запроса именем, должно иметь определённый и уникальный псевдоним. Это нужно для возможности однозначного создания класса-курсора, поля которого соответствуют именам столбцов запроса.

. Не поддерживается конструкция ORDER BY, т. к. при необходимости определённым образом отсортировать результирующий набор следует воспользоваться методом orderBy(...) соответствующего курсора.

. Не поддерживается конструкция GROUP BY...HAVING (разработка поддержки этой конструкции возможна лишь при возникновении обоснованной необходимости в данной функциональности).

. Не поддерживаются FULL JOIN (объединения LEFT и RIGHT joins) и CROSS JOIN (декартовы произведения таблиц). Практическая значимость FULL JOIN сомнительна. CROSS JOIN сам по себе также не бывает практически необходим, неосторожное использование может привести к проблемам производительности.

. Не поддерживаются конструкции UNION, WITH, любые вложенные запросы. Конструкция бизнес-приложения должна предусматривать достаточное количество таблиц с данными, чтобы в этих конструкциях не было необходимости.

Ссылка на таблицу (*table_ref*) имеет синтаксис

image::{img}/6.table_ref_1.png[{image-60-width}]

Имя гранулы указывать не обязательно, если таблица находится в той же грануле, что и текущее представление.

Терм, определяющий поле представления, имеет следующий синтаксис:

image::{img}/21.term.png[{image-60-width}]

Над выражениям типа INTEGER и REAL допустимы обычные арифметические операции с обычным приоритетом: максимальный приоритет у унарного минуса, далее — умножение и деление («*», «/»), далее — сложение и вычитание («+», «-»). Над выражениями типа NVARCHAR допустима операция конкатенации «||». Операции над полями прочих типов недопустимы.

image::{img}/22.primary_term.png[{image-70-width}]

Ссылки на поля могут быть однокомпонентными (если они однозначно указывают на поле определённой таблицы) либо двухкомпонентными, в этом случае в качестве первой компоненты следует указывать псевдоним таблицы из конструкции FROM либо — если явный псевдоним отсутствует — имя таблицы.

Наконец, синтаксис логического выражения *condition*, используемого в конструкциях JOIN ... ON и WHERE:

image::{img}/23.condition.png[{image-70-width}]

image::{img}/24.predicate.png[{image-60-width}]

image::{img}/25.aggregate.png[{image-80-width}]

Стоит отметить, что term внутри конструкции SUM должен являться числом.

image::{img}/26.group_by.png[{image-60-width}]

Особенность конструкции GROUP BY в Celesta-SQL заключается в необходимости всегда перечислять в ней все неагрегатные колоноки из выборки.

[[create_materialized_view_statement]]
== Конструкция CREATE MATERIALIZED VIEW

Материализованные представления (materialized views) служат для доступа только на чтение к агрегатным данным, собранным из одной таблицы и объединенным при помощи выражения GROUP BY. Для каждого своего материализованного представления Celesta создаёт таблицу в базе данных, модифицируемую триггерами при изменении родительской таблицы.

Материализованные представления создаются при помощи синтаксической конструкции

image::{img}/950px-Create_materialized_view.png[{image-100-width}]

Основными ограничениями и отличиями такого запроса от SQL-запросов в различных СУБД являются:

. Запросы строятся только на таблицe текущей гранулы.

. Конструкция SELECT * не поддерживается, и всякое поле запроса, если только это не ссылка на поле таблицы с уникальным в рамках запроса именем, должно иметь определённый и уникальный псевдоним. Это нужно для возможности однозначного создания класса-курсора, поля которого соответствуют именам столбцов запроса.

. В выборке обязательно должен участвовать хотя бы один агрегатный и хотя бы один неагрегатный столбец.

. Неагрегатные колонки должны ссылаться на not null колонки родительской таблицы.

. Если в group by выражении участвует колонка типа datetime, то ее значения будут округляться в точности до дня (часы, минуты и более точные измерения отсекаются).

image::{img}/Materialized_aggregate.png[{image-80-width}]

[[create_function_statement]]
== Конструкция CREATE FUNCTION

Функции — они же параметризованные представления. Служат для доступа только на чтение к данным, собранным из одной или нескольких таблиц при помощи SQL-запроса SELECT с учетом переданных параметров.

Функции создаются при помощи синтаксической конструкции

image::{img}/Create_function.png[{image-100-width}]

image::{img}/Param_definition.png[{image-50-width}]

image::{img}/Param_literal.png[{image-30-width}]

Основными ограничениями и отличиями такого запроса от SQL-запросов в различных СУБД являются:

. Конструкция SELECT * не поддерживается, и всякое поле запроса, если только это не ссылка на поле таблицы с уникальным в рамках запроса именем, должно иметь определённый и уникальный псевдоним. Это нужно для возможности однозначного создания класса-курсора, поля которого соответствуют именам столбцов запроса.

. В объявлении обязательно должен иметься хотя бы один параметр.

. Все объявленные параметры обязательно должны использоваться.

В остальном синтаксическое выражение аналогично обычному View.

Пример функции:

[source, sql]
CREATE FUNCTION pView2(param int,/*TEST*/ param2 varchar) AS
  select f1, f2, f3 from t1
  where f2 = $param AND f3 = $param2 AND f3 = $param2;

//end::celesta_sql[]
